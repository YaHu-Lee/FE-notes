---
typora-root-url: ..
---

# V8 编译流水线

## 运行时环境

V8 运行时环境在执行 JS 代码之前就已经准备好。这个环境包含了堆空间、栈空间、全局执行上下文、全局作用域、内建函数、宿主的扩展函数与对象，以及消息循环系统。

![img](/assets/9ad5d32bce98aad219c9f73513ac6349.jpg)

当 V8 接受到一份 JS 代码时，就能够开始按照下图所示的流程运转起来：

![img](/assets/a89d747fb614a17e08b1a6b7dce62b54.jpg)

浏览器为 V8 提供基础的消息循环系统、全局变量、Web API，而 V8 的核心是实现了 ECMAScript 标准，这相当于病毒自己的 DNA 或者 RNA，V8 只提供了 ECMAScript 定义的一些对象和一些核心的函数，这包括了 Object、Function、String。除此之外，V8 还提供了垃圾回收器、协程等基础内容，不过这些功能依然需要宿主环境的配合才能完整执行。如果 V8 使用不当，比如不规范的代码触发了频繁的垃圾回收，或者某个函数执行时间过久，这些都会占用宿主环境的主线程，从而影响到程序的执行效率，甚至导致宿主环境的卡死。

Node.js 也是 V8 的另外一种宿主环境，它提供了不同的宿主对象和宿主的 API，但是整个流程依然是相同的，比如 Node.js 也会提供一套消息循环系统，也会提供一个运行时的主线程。

![img](/assets/e541d8611b725001509bfcd6797f492f.jpg)

### 堆栈空间

在函数调用过程中，涉及到上下文相关的内容都会存放在栈上，比如原生类型、引用到的对象的地址、函数的执行状态、this 值等都会存在在栈上。当一个函数执行结束，那么该函数的执行上下文便会被销毁掉。栈空间的最大的特点是空间连续，所以在栈中每个元素的地址都是固定的，因此栈空间的查找效率非常高，但是通常在内存中，很难分配到一块很大的连续空间，因此，V8 对栈空间的大小做了限制，如果函数调用层过深，那么 V8 就有可能抛出栈溢出的错误。

堆空间是一种树形的存储结构，用来存储对象类型的离散的数据，在前面的课程中我们也讲过，JavaScript 中除了原生类型的数据，其他的都是对象类型，诸如函数、数组，在浏览器中还有 window 对象、document 对象等，这些都是存在堆空间的。

宿主在启动 V8 的过程中，会同时创建堆空间和栈空间，再继续往下执行，产生的新数据都会存放在这两个空间中。

### 全局执行上下文和全局作用域

当 V8 开始执行一段可执行代码时，会生成一个执行上下文。V8 用执行上下文来维护执行当前代码所需要的变量声明、this 指向等。执行上下文中主要包含三部分，**变量环境、词法环境和 this 关键字**。比如在浏览器的环境中，全局执行上下文中就包括了 window 对象，还有默认指向 window 的 this 关键字，另外还有一些 Web API 函数，诸如 setTimeout、XMLHttpRequest 等内容。而词法环境中，则包含了使用 let、const 等变量的内容。

![img](/assets/0b4929e11b49856037ffdcf00508d4f5.jpg)

全局执行上下文是最顶层的执行上下文，在 V8 的生存周期内是不会被销毁的，它会一直保存在堆中，这样当下次在需要使用函数或者全局变量时，就不需要重新创建了。另外，当你执行了一段全局代码时，如果全局代码中有声明的函数或者定义的变量，那么函数对象和声明的变量都会被添加到全局执行上下文中。

作用域在代码写出的时候就确定了，它决定了代码对变量的访问权限。JS 采用的是词法作用域，即静态作用域，因此才会有 JS 中的闭包。非要说的话，上下文是横向概念，而作用域是纵向概念。如果具体到某一个函数，那么在函数执行前其作用域已经确定，执行时首先创建其全局执行上下文，然后将其作用域链也添加到这个执行上下文中，才开始执行。即全局执行上下文+函数参数+作用域链=局部执行上下文。

### 构造事件循环系统

有点复杂，先放着

## V8 内存布局

### 引子

```js
function foo() {
  foo(); // 是否存在堆栈溢出错误?
}
foo();
```

```js
function foo() {
  setTimeout(foo, 0); // 是否存在堆栈溢出错误?
}
```

```js
function foo() {
  return Promise.resolve().then(foo);
}
foo();
```

第一段造成栈溢出的错误，第二段能够正确执行，而第三段没有栈溢出的错误，却会造成页面的卡死

第一段代码是在同一个任务中重复调用嵌套的 foo 函数；第二段代码是使用 setTimeout 让 foo 函数在不同的任务中执行；第三段代码是在同一个任务中执行 foo 函数，但是却不是嵌套执行。

V8 执行这三种不同代码时，它们的内存布局是不同的，而不同的内存布局又会影响到代码的执行逻辑。

第一段代码由于循环嵌套调用了 foo，所以当函数运行时，就会导致 foo 函数会不断地调用 foo 函数自身，这样就会导致栈无限增，进而导致栈溢出的错误。第二段代码是在函数内部使用了 setTimeout 来启动 foo 函数，这段代码之所以不会导致栈溢出，是因为 setTimeout 会使得 foo 函数在消息队列后面的任务中执行，所以不会影响到当前的栈结构。 也就不会导致栈溢出。最后一段代码是 Promise，Promise 的情况比较特别，将会使代码陷入同一个微任务时期，虽然不会造成栈溢出，但是会导致主线的卡死。

## 惰性解析与闭包

所谓惰性解析是指解析器在解析的过程中，如果遇到函数声明，那么会跳过函数内部的代码，并不会为其生成 AST 和字节码，而仅仅生成顶层代码的 AST 和字节码。

```js
function foo(a, b) {
  var d = 100;
  var f = 10;
  return d + f + a + b;
}
var a = 1;
var c = 4;
foo(1, 5);
```

当把这段代码交给 V8 处理时，V8 会至上而下解析这段代码，在解析过程中首先会遇到 foo 函数，由于这只是一个函数声明语句，V8 在这个阶段只需要将该函数转换为函数对象，如下图所示：

![img](/assets/35ce3f6469a7024ca14d81b6c804044a.jpg)

这里只是将该函数声明转换为函数对象，但是并没有解析和编译函数内部的代码，所以也不会为 foo 函数的内部代码生成抽象语法树。然后继续往下解析，由于后续的代码都是顶层代码，所以 V8 会为它们生成抽象语法树，最终生成的结果如下所示：

![img](/assets/e52476efb6ef924e74f470ead4970262.jpg)

代码解析完成之后，V8 便会按照顺序自上而下执行代码，首先会先执行“a=1”和“c=4”这两个赋值表达式，接下来执行 foo 函数的调用，过程是从 foo 函数对象中取出函数代码，然后和编译顶层代码一样，V8 会先编译 foo 函数的代码，编译时同样需要先将其编译为抽象语法树和字节码，然后再解释执行。这就是惰性解析的一个大致过程，看上去很简单，不过在 V8 实现惰性解析的过程中，需要支持 JavaScript 中的闭包特性，这会使得 V8 的解析过程变得异常复杂。请看实例：

```js
function foo() {
  var d = 20;
  return function inner(a, b) {
    const c = a + b + d;
    return c;
  };
}
const f = foo();
```

当调用 foo 函数时，foo 函数会将它的内部函数 inner 返回给全局变量 f；然后 foo 函数执行结束，执行上下文被 V8 销毁；虽然 foo 函数的执行上下文被销毁了，但是依然存活的 inner 函数引用了 foo 函数作用域中的变量 d。

按照通用的做法，d 已经被 v8 销毁了，但是由于存活的函数 inner 依然引用了 foo 函数中的变量 d，这样就会带来两个问题：当 foo 执行结束时，变量 d 该不该被销毁？如果不应该被销毁，那么应该采用什么策略？如果采用了惰性解析，那么当执行到 foo 函数时，V8 只会解析 foo 函数，并不会解析内部的 inner 函数，那么这时候 V8 就不知道 inner 函数中是否引用了 foo 函数的变量 d。

为了保持闭包的正常运转，在执行 foo 函数的阶段，虽然采取了惰性解析，不会解析和执行 foo 函数中的 inner 函数，但是 V8 还是需要判断 inner 函数是否引用了 foo 函数中的变量，负责处理这个任务的模块叫做预解析器。

比如当解析顶层代码的时候，遇到了一个函数，那么预解析器并不会直接跳过该函数，而是对该函数做一次快速的预解析，其主要目的有两个。

第一，是判断当前函数是不是存在一些语法上的错误；

第二，除了检查语法错误之外，预解析器另外的一个重要的功能就是检查函数内部是否引用了外部变量，如果引用了外部的变量，预解析器会将栈中的变量复制到**堆中**（栈中的东西仍然全都清掉），在下次执行到该函数的时候，直接使用堆中的引用，这样就解决了闭包所带来的问题。

## 字节码

字节码（英语：Bytecode）通常指的是已经经过编译，但与特定机器代码无关，需要解释器转译后才能成为机器代码的中间代码。字节码通常不像源码一样可以让人阅读，而是编码后的数值常量、引用、指令等构成的序列。

### 字节码的优点

要了解字节码的优点，最直观的方式就是直接看字节码给 java 带来了什么，早期 java 推广的口号就是 Compile Once，Run anywhere（一次编译到处运行），Java 源代码经过编译程序编译之后生成扩展名为.class 的字节码文件。再通过 JVM 将字节码翻译为机器的计算机指令（目标机器必须要安装对应的 JVM(java 虚拟机)）。
Java 语言使用字节码的方式，一定程度的解决了解释性语言执行效率低的问题，同时由于字节码不针对一种特定的机器，所以 Java 程序无须重新编译就可在多种不同的计算机上运行。

字节码的优点总结来说就是：

- 不针对特定 CPU 架构
- 比原始的高级语言转换成机器语言更快

### V8 中的字节码

V8 在执行一段 JavaScript 代码之前，需要将其编译为字节码，然后再解释执行字节码或者将字节码编译为二进制代码然后再执行。早期的 V8 并不是这样设计的，那时候 V8 团队认为这种“先生成字节码再执行字节码”的方式，多了个中间环节，多出来的中间环节会牺牲代码的执行速度。V8 团队这种想法，或多或少是出于“对抗 JavaScriptCore”的意图。因为当时 JavaScriptCore 是主流的 JS 引擎，采用的就是源码到字节码再到二进制代码的思路。于是在早期，V8 团队采取了非常激进的策略，直接将 JavaScript 代码编译成机器代码。其执行流程如下图所示：

![img](/assets/6a9f1a826b924eb74f0ab08a18528a68.jpg)

观察上面的执行流程图，我们可以发现，早期的 V8 也使用了两个编译器：第一个是基线编译器，它负责将 JavaScript 代码编译为没有优化过的机器代码。第二个是优化编译器，它负责将一些热点代码（执行频繁的代码）优化为执行效率更高的机器代码。

了解这两个编译器之后，接下来我们再来看看早期的 V8 是怎么执行一段 JavaScript 代码的。首先，V8 会将一段 JavaScript 代码转换为抽象语法树 (AST)。接下来基线编译器会将抽象语法树编译为未优化过的机器代码，然后 V8 直接执行这些未优化过的机器代码。在执行未优化的二进制代码过程中，如果 V8 检测到某段代码重复执行的概率过高，那么 V8 会将该段代码标记为 HOT，标记为 HOT 的代码会被优化编译器优化成执行效率高的二进制代码，然后就执行该段优化过的二进制代码。不过如果优化过的二进制代码并不能满足当前代码的执行，这也就意味着优化失败，V8 则会执行反优化操作。

既然直接编译机器码如此高效，为何要重新采用字节码呢？

### 机器代码缓存

当 JavaScript 代码在浏览器中被执行的时候，需要先被 V8 编译，早期的 V8 会将 JavaScript 编译成未经优化的二进制机器代码，然后再执行这些未优化的二进制代码，通常情况下，编译占用了很大一部分时间，下面是一段代码的编译和执行时间图：

![img](/assets/d5b8e781606efa91362c856656de3ebb.jpg)

从图中可以看出，编译所消耗的时间和执行所消耗的时间是差不多的，试想一下，如果在浏览器中再次打开相同的页面，当页面中的 JavaScript 文件没有被修改，那么再次编译之后的二进制代码也会保持不变， 这意味着编译这一步白白浪费了 CPU 资源，因为之前已经编译过一次了。这就是 Chrome 浏览器引入二进制代码缓存的原因，通过把二进制代码保存在内存中来消除冗余的编译，重用它们完成后续的调用，这样就省去了再次编译的时间。

V8 使用两种代码缓存策略来缓存生成的代码。首先，是 V8 第一次执行一段代码时，会编译源 JavaScript 代码，并将编译后的二进制代码缓存在内存中，我们把这种方式称为内存缓存（in-memory cache)。然后通过 JavaScript 源文件的字符串在内存中查找对应的编译后的二进制代码。这样当再次执行到这段代码时，V8 就可以直接去内存中查找是否编译过这段代码。如果内存缓存中存在这段代码所对应的二进制代码，那么就直接执行编译好的二进制代码。其次，V8 除了采用将代码缓存在内存中策略之外，还会将代码缓存到硬盘上，这样即便关闭了浏览器，下次重新打开浏览器再次执行相同代码时，也可以直接重复使用编译好的二进制代码。

![img](/assets/a6f2ea6df895eb6940a9db95f54fa360.jpg)

实践表明，在浏览器中采用了二进制代码缓存的方式，初始加载时分析和编译的时间缩短了 20%～ 40%。所以在早期，Chrome 做了两件事来提升 JavaScript 代码的执行速度：第一，将运行时将二进制机器代码缓存在内存中；第二，当浏览器退出时，缓存编译之后二进制代码到磁盘上。很明显，采用缓存是一种典型的以空间换时间的策略，以牺牲存储空间来换取执行速度，我们知道 Chrome 的多进程架构已经非常吃内存了，而 Chrome 中每个页面进程都运行了一份 V8 实例，V8 在执行 JavaScript 代码的过程中，会将 JavaScript 代码转换为未经优化的二进制代码，你可以对照下图中的 JavaScript 代码和二进制代码：

![img](/assets/214d4c793543d08e16f86abd82a9accb.jpg)

从上图我们可以看出，二进制代码所占用的内存空间是 JavaScript 代码的几千倍，通常一个页面的 JavaScript 几 M 大小，转换为二进制代码就变成几十 M 了，如果是 PC 应用，多占用一些内存，也不会太影响性能，但是在移动设备流行起来之后，V8 过度占用内存的问题就充分暴露出来了。因为通常一部手机的内存不会太大，如果过度占用内存，那么会导致 Web 应用的速度大大降低。

### 惰性解析之殇

在当时的 Chrome 浏览器下重复加载 Facebook，并打开各项监控发现：第一次加载时 v8.CompileScript 花费了 165 ms，而重复加载时发现真正耗时高的 js 代码并没有被缓存，导致重复加载时编译的时间和第一次加载的消耗大致相同。

导致这个问题的原因其实也很好理解，之前提到过因为二进制代码占用内存空间大，根据惰性编译的优化原则，所以 V8 并不会将所有代码进行编译只会编译最外层的代码，而在函数内部的代码会在第一次调用时编译，比如：

![img](/assets/fasefszsfsezfzfs.png)

**速度慢**

**吃内存**

**太复杂**

因此，V8 团队对早期的 V8 架构进行了非常大的重构，具体地讲，抛弃之前的基线编译器和优化编译器，引入了字节码、解释器和新的优化编译器。

![img](/assets/27d30dbb95e3bb3e55b9bc2a56e14d4b.jpg)

从图中可以看出，字节码虽然占用的空间比原始的 JavaScript 多，但是相较于机器代码，字节码还是小了太多。有了字节码，无论是解释器的解释执行，还是优化编译器的编译执行，都可以直接针对字节来进行操作。由于字节码占用的空间远小于二进制代码，所以浏览器就可以实现缓存所有的字节码，而不是仅仅缓存顶层的字节码。

虽然采用字节码在执行速度上稍慢于机器代码，但是整体上权衡利弊，采用字节码也许是最优解。之所以说是最优解，是因为采用字节码除了降低内存之外，还**提升了代码的启动速度，并降低了代码的复杂度**，而牺牲的仅仅是一点执行效率。

### 字节码如何提升代码启动速度？

![img](/assets/9e441845eb4af12642fe5385cdd1b05b.jpg)

生成机器代码比生成字节码需要花费更久的时间，但是直接执行机器代码却比解释执行字节码要更高效，所以在快速启动 JavaScript 代码与花费更多时间获得最优运行性能的代码之间，我们需要找到一个平衡点。

解释器可以快速生成字节码，但字节码通常效率不高。 相比之下，优化编译器虽然需要更长的时间进行处理，但最终会产生更高效的机器码，这正是 V8 在使用的模型。它的解释器叫 **Ignition**，（就原始字节码执行速度而言）是所有引擎中最快的解释器。V8 的优化编译器名为 **TurboFan**，最终由它生成高度优化的机器码。

### 字节码如何降低代码的复杂度？

早期的 V8 代码，无论是基线编译器还是优化编译器，它们都是基于 AST 抽象语法树来将代码转换为机器码的，我们知道，不同架构的机器码是不一样的，而市面上存在不同架构的处理器又是非常之多

![img](/assets/bc8ede549e0572689cadd6f2c21f31e9.jpg)

这意味着基线编译器和优化编译器要针对不同的体系的 CPU 编写不同的代码，这会大大增加代码量。引入了字节码，就可以统一将字节码转换为不同平台的二进制代码，你可以对比下执行流程：

![img](/assets/0b207ca6b427bf6281dce67d4f96835d.jpg)

因为字节码的执行过程和 CPU 执行二进制代码的过程类似，相似的执行流程，那么将字节码转换为不同架构的二进制代码的工作量也会大大降低，这就降低了转换底层代码的工作量。

### 执行字节码

Ignition 引擎可以对字节码进行解释执行，那就是说他的功能类似于 Java 的 JVM，本质上就是一个虚拟机。 虚拟机通常有两种分别是基于 Stack（栈）的和基于 Register（寄存器）的， 比如基于 Stack 的虚拟机有 JVM，是一种比较广泛的实现方法，而我们 V8 引擎中的 Ignition 是基于 Register 的，也就是基于寄存器的虚拟机，通常基于 Register 的虚拟机比基于 Stack 的虚拟机执行的更快，但是指令相对较长。

Ignition 是一个带有累加器（accumulator）的引擎

```js
var x = 100;
var y = x + 10;
x = x * y;
```

![img](/assets/sgsdggdxdgxdfg.png)

接下来会通过[Google 官方 PPT](https://docs.google.com/presentation/d/1HgDDXBYqCJNasBKBDf9szap1j4q4wnSHhOYpaNy5mHU/edit#slide=id.g1453eb7f19_5_214)上面的一段案例来解读 V8 上字节码的执行。

先将源码转换成字节码

![img](/assets/yuanmazhuanhuanweizijiema.png)

进行函数 **f** 的初始化工作

![img](/assets/hanshufchushihua.png)

将小整数 -100 存储到累加器中，LdaSmi 可以理解为一个定义好的 handle 函数 后面接的 #100 就是这个函数的参数

![img](/assets/jianfayunsuan.png)

将 a2 中存储的 150 和累加器中的值求和，并将结果存于累加器 。

![img](/assets/leijiaqiqiuhe.png)

将累加器中存储的 50 保存到寄存器 r0 中，此时 r0 的值为 50。

![img](/assets/baocundaor0.png)

将寄存器 a1 也就是参数 b 的值存储到累加器中，此时累加器值为 2。（a0、a1、a2 也是寄存器）

![img](/assets/canshubcunchu.png)

将寄存器 r0 中的值和累加器中的值求乘积，并将结果存于累加器。

![img](/assets/r0yuleijiaqiqiuji.png)

将寄存器 a0 中的值和累加器中的值求和，并将结果存于累加器。

![img](/assets/a0yuleijiaqiqiuhe.png)

Return （包括上面的语句）本身都是定义好的 handle 函数，Return 代表的就是将累加器中的值返回。

![img](/assets/fanhuileijiaqizhongdezhi.png)

### V8 字节码表

![img](/assets/17221eabf99b98a3.png)

实际运行测试：

```js
// https://medium.com/dailyjs/understanding-v8s-bytecode-317d46c94775
// node --print-bytecode --print-bytecode-filter=ZXC v8-bytecode.js
function ZXC(a, b, c) {
  const d = a + b;
  return d + c + 200;
}
ZXC(1, 2, 3);

/*
[generated bytecode for function: ZXC (0x00577cffaa11 <SharedFunctionInfo ZXC>)]
Parameter count 4
Register count 1
Frame size 8
  177 S> 000000577CFFB136 @    0 : 25 03             Ldar a1
  179 E> 000000577CFFB138 @    2 : 34 04 00          Add a0, [0]
         000000577CFFB13B @    5 : 26 fb             Star r0
  186 S> 000000577CFFB13D @    7 : 25 02             Ldar a2
  195 E> 000000577CFFB13F @    9 : 34 fb 01          Add r0, [1]
  199 E> 000000577CFFB142 @   12 : 00 40 c8 00 02 00 AddSmi.Wide [200], [2]
  204 S> 000000577CFFB148 @   18 : aa                Return
Constant pool (size = 0)
Handler Table (size = 0)
Source Position Table (size = 15)
0x00577cffb151 <ByteArray[15]>
 */
```

### 字节码优化 隐藏类

#### 相比于 C++ ，JS 为甚么慢？

JavaScript 在运行时，对象的属性是可以被修改的，所以当 V8 使用了一个对象时，比如使用了 start.x 的时候，它并不知道该对象中是否有 x，也不知道 x 相对于对象的偏移量是多少，也可以说 V8 并不知道该对象的具体的形状。那么，当在 JavaScript 中要查询对象 start 中的 x 属性时，V8 会按照具体的规则一步一步来查询，这个过程非常的慢且耗时。

C++ 在声明一个对象之前需要定义该对象的结构，我们也可以称为形状，那么在 C++ 中访问一个对象的属性时，自然就知道该属性相对于该对象地址的偏移值了，比如在 C++ 中使用 start.x 的时候，编译器会直接将 x 相对于 start 的地址写进汇编指令中，那么当使用了对象 start 中的 x 属性时，CPU 就可以直接去内存地址中取出该内容即可，没有任何中间的查找环节。

#### 在 V8 中引入辅助工具--隐藏类

V8 对每个对象做如下两点假设：

- 对象创建好了之后就不会添加新的属性；
- 对象创建好了之后也不会删除属性。

具体地讲，V8 会为每个对象创建一个隐藏类，对象的隐藏类中记录了该对象一些基础的布局信息，包括以下两点：

- 对象中所包含的所有的属性；
- 每个属性相对于对象的偏移量。

结合一段代码来分析下隐藏类是怎么工作的

```js
let point = { x: 100, y: 200 };
```

当 V8 执行到这段代码时，会先为 point 对象创建一个隐藏类，在 V8 中，把隐藏类又称为 map，每个对象都有一个 map 属性，其值指向内存中的隐藏类。

隐藏类描述了对象的属性布局，它主要包括了属性名称和每个属性所对应的偏移量，比如 point 对象的隐藏类就包括了 x 和 y 属性，x 的偏移量是 4，y 的偏移量是 8。

![img](/assets/51f5034a7f80e4e5684d5a301178c2f8.jpg)

如果两个对象的形状是相同的，V8 就会为其复用同一个隐藏类。

如果某个对象的形状改变了，隐藏类也会随着改变，这意味着 V8 要为新改变的对象重新构建新的隐藏类，这对于 V8 的执行效率来说，是一笔大的开销。

#### 最佳实践

一，使用字面量初始化对象时，要保证属性的顺序是一致的。比如先通过字面量 x、y 的顺序创建了一个 point 对象，然后通过字面量 y、x 的顺序创建一个对象 point2，代码如下所示：

```js
let point = { x: 100, y: 200 };
let point2 = { y: 100, x: 200 };
```

虽然创建时的对象属性一样，但是它们初始化的顺序不一样，这也会导致形状不同，所以它们会有不同的隐藏类，所以我们要尽量避免这种情况。

二，尽量使用字面量一次性初始化完整对象属性。因为每次为对象添加一个属性时，V8 都会为该对象重新设置隐藏类。

三，尽量避免使用 delete 方法。delete 方法会破坏对象的形状，同样会导致 V8 为该对象重新生成新的隐藏类。

### 字节码优化 内联缓存与反馈向量

```js
function loadX(o) {
  return o.x;
}
var o = { x: 1, y: 3 };
var o1 = { x: 3, y: 6 };
for (var i = 0; i < 90000; i++) {
  loadX(o);
  loadX(o1);
}
```

V8 获取 o.x 的流程是这样的：查找对象 o 的隐藏类，再通过隐藏类查找 x 属性偏移量，然后根据偏移量获取属性值，在这段代码中 loadX 函数会被反复执行，那么获取 o.x 流程也需要反复被执行。

V8 会想尽一切办法来压缩这个查找过程，以提升对象的查找效率。这个加速函数执行的策略就是内联缓存 (Inline Cache)，简称为 IC。V8 执行函数的过程中，会观察函数中一些调用点 (CallSite) 上的关键的中间数据，然后将这些数据缓存起来，当下次再次执行该函数的时候，V8 就可以直接利用这些中间数据，节省了再次获取这些数据的过程，因此 V8 利用 IC，可以有效提升一些重复代码的执行效率。

IC 会为每个函数维护一个反馈向量 (FeedBack Vector)，反馈向量记录了函数在执行过程中的一些关键的中间数据。

![img](/assets/0f49d225b1ed71aaccd3cca2d1226dd3.jpg)

反馈向量其实就是一个表结构，它由很多项组成的，每一项称为一个插槽 (Slot)，V8 会依次将执行 loadX 函数的中间数据写入到反馈向量的插槽中。比如

```js
function loadX(o) {
  o.y = 4;
  return o.x;
}
```

当 V8 执行这段函数的时候，它会判断 o.y = 4 和 return o.x 这两段是调用点 (CallSite)，因为它们使用了对象和属性，那么 V8 会在 loadX 函数的反馈向量中为每个调用点分配一个插槽。

每个插槽中包括了插槽的索引 (slot index)、插槽的类型 (type)、插槽的状态 (state)、隐藏类 (map) 的地址、还有属性的偏移量，比如上面这个函数中的两个调用点都使用了对象 o，那么反馈向量两个插槽中的 map 属性也都是指向同一个隐藏类的，因此这两个插槽的 map 地址是一样的。

![img](/assets/609490b948c4a085e8f992de08a44549.jpg)

来看下当 V8 执行 loadX 函数时，loadX 函数中的关键数据是如何被写入到反馈向量中。

```js
function loadX(o) {
  return o.x;
}
loadX({ x: 1 });
```

字节码：

```assembly
StackCheck
LdaNamedProperty a0, [0], [0]
Return
```

第一句是检查栈是否溢出；第二句是 LdaNamedProperty，它的作用是取出参数 a0 的第一个属性值，并将属性值放到累加器中；第三句是返回累加器中的属性值。

LdaNamedProperty 这句字节码，我们看到它有三个参数。a0 就是 loadX 的第一个参数；第二个参数[0]表示取出对象 a0 的第一个属性值，这两个参数很好理解。第三个参数就和反馈向量有关了，它表示将 LdaNamedProperty 操作的中间数据写入到反馈向量中，方括号中间的 0 表示写入反馈向量的第一个插槽中。具体你可以参看下图

![img](/assets/a170f18653cea4b02bc9afb96b9f3764.jpg)

在 map 栏，缓存了 o 的隐藏类的地址；在 offset 一栏，缓存了属性 x 的偏移量；在 type 一栏，缓存了操作类型，这里是 LOAD 类型。在反馈向量中，我们把这种通过 o.x 来访问对象属性值的操作称为 **LOAD** 类型。

V8 除了缓存 o.x 这种 LOAD 类型的操作以外，还会缓存存储 (**STORE**) 类型和函数调用 (**CALL**) 类型的中间数据。

```js
function foo(){}
function loadX(o) {
    o.y = 4
    foo()
    return o.x
}
loadX({x:1,y:4})


StackCheck

//这段代码是先使用 LdaSmi [4]，将常数 4 加载到累加器中，然后通过 StaNamedProperty 的字节码指令，将累加器中的 4 赋给 o.y，这是一个存储 (STORE) 类型的操作，V8 会将操作的中间结果存放到反馈向量中的第一个插槽中。
LdaSmi [4]
StaNamedProperty a0, [0], [0]

//解释器首先加载 foo 函数对象的地址到累加器中，这是通过 LdaGlobal 来完成的，然后 V8 会将加载的中间结果存放到反馈向量的第 3 个插槽中，这是一个存储类型的操作。接下来执行 CallUndefinedReceiver0，来实现 foo 函数的调用，并将执行的中间结果放到反馈向量的第 5 个插槽中，这是一个调用 (CALL) 类型的操作。
LdaGlobal [1], [2]
Star r0
CallUndefinedReceiver0 r0, [4]

//最后就是返回 o.x，return o.x 仅仅是加载对象中的 x 属性，所以这是一个加载 (LOAD) 类型的操作，我们在上面介绍过的。最终生成的反馈向量如下图所示：
LdaNamedProperty a0, [2], [6]
Return
```

![img](/assets/ab7b91aea94d35ff2e6023aef05b56b4.jpg)

![img](/assets/ba826723b58509527fd2f316214092cb.jpg)

当 V8 再次调用 loadX 函数时，比如执行到 loadX 函数中的 return o.x 语句时，它就会在对应的插槽中查找 x 属性的偏移量，之后 V8 就能直接去内存中获取 o.x 的属性值了。这样就大大提升了 V8 的执行效率。

#### 多态与超态

```js
function loadX(o) {
  return o.x;
}
var o = { x: 1, y: 3 };
var o1 = { x: 3, y: 6, z: 4 };
for (var i = 0; i < 90000; i++) {
  loadX(o);
  loadX(o1);
}
```

第一次执行时 loadX 时，V8 会将 o 的隐藏类记录在反馈向量中，并记录属性 x 的偏移量。那么当再次调用 loadX 函数时，V8 会取出反馈向量中记录的隐藏类，并和新的 o1 的隐藏类进行比较，发现不是一个隐藏类，那么此时 V8 就无法使用反馈向量中记录的偏移量信息了。

面对这种情况，V8 会选择将新的隐藏类也记录在反馈向量中，同时记录属性值的偏移量，这时，反馈向量中的第一个槽里就包含了两个隐藏类和偏移量。

![img](/assets/63f3caf97413881481bc6a86cdf065b6.jpg)

如果一个插槽中只包含 1 个隐藏类，那么我们称这种状态为单态 (**monomorphic**)；如果一个插槽中包含了 2 ～ 4 个隐藏类，那我们称这种状态为多态 (**polymorphic**)；如果一个插槽中超过 4 个隐藏类，那我们称这种状态为超态 (**magamorphic**)。

插槽中包含了 2 ～ 4 个隐藏类，那么可以使用线性结构来存储，如果超过 4 个，那么 V8 会采取 hash 表的结构来存储，这无疑会拖慢执行效率。

要避免多态和超态，那么就尽量默认所有的对象属性是不变的，比如你写了一个 loadX(o) 的函数，那么当传递参数时，尽量不要使用多个不同形状的 o 对象。

思考题：谁的效率更高？

```js
let data = [1, 2, 3, 4]
data.forEach((item) => console.log(item.toString())

let data = ['1', 2, '3', 4]
data.forEach((item) => console.log(item.toString())
```

_本文系极客时间李兵付费专栏学习笔记，转载请注明原作者李兵，详细学习请订阅该专栏_
